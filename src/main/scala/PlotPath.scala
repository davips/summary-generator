import scala.io.Source

object PlotPath extends App {
  println("Choose file name and desired rows by timestamp in the code! The output will be XY scatter plots side by side to put in a spreadsheet like gnumeric.")
  val rows = Seq("75704555", "79092094")
  val allMode = !true
  val file1c = "f5-0-10x10-100-1c-999999.on.5000.log"
  //res:    10178   3658.37 8095.661        6464    2744    889     81      10178   90      RationalQuadratic(alpha=1,_length_scale=1)      100.0   99.697  [(1.0, 1.0), (0.12, 1.0), (1.0, 0.12), (0.61, 1.0), (1.0, 0.61), (0.37, 1.0), (1.0, 0.37), (0.81, 1.0), (1.0, 0.81), (0.0, 0.92), (0.92, 0.0), (0.12, 0.12), (0.12, 0.38), (0.63, 0.37), (0.62, 0.63), (0.13, 0.63), (0.62, 0.13), (0.37, 0.12), (0.38, 0.63), (0.37, 0.38), (0.85, 0.63), (0.24, 0.9), (0.9, 0.24), (0.63, 0.85), (0.86, 0.41), (0.41, 0.86), (0.86, 0.86), (0.82, 0.12), (0.12, 0.82), (1.0, 0.49), (0.49, 1.0), (0.63, 0.0), (0.0, 0.62), (0.0, 0.13), (0.12, 0.0), (0.38, 0.0), (0.0, 0.37), (0.91, 0.73), (0.73, 0.91), (0.5, 0.37), (0.13, 0.25), (0.62, 0.5), (0.38, 0.25), (1.0, 0.25), (0.25, 1.0), (0.12, 0.51), (0.49, 0.12), (0.26, 0.62), (0.24, 0.13), (0.37, 0.51), (0.24, 0.37), (0.0, 1.0), (1.0, 0.0), (0.5, 0.62), (0.75, 0.37), (0.37, 0.75), (0.63, 0.25), (0.73, 0.62), (0.52, 0.89), (0.89, 0.52), (0.63, 0.74), (0.94, 0.92), (0.72, 0.12), (0.71, 1.0), (1.0, 0.71), (0.11, 0.72), (0.9, 1.0), (0.31, 0.84), (0.84, 0.31), (0.11, 0.91), (0.91, 0.11), (0.0, 0.83), (0.83, 0.0), (0.77, 0.83), (0.33, 0.93), (0.93, 0.33), (0.43, 0.44), (0.83, 0.74), (0.56, 0.06), (0.56, 0.43), (0.18, 0.44), (1.0, 0.9), (0.31, 0.06), (0.31, 0.19), (0.69, 0.44), (0.31, 0.44), (0.31, 0.31), (0.07, 0.19), (0.56, 0.19)]   [0, 35, 12, 49, 84, 18, 83, 36, 47, 79, 32, 73, 11, 53, 3, 71, 28, 63, 17, 89, 57, 14, 85, 55, 69, 23, 44, 7, 76, 25, 60, 30, 5, 65, 38, 21, 58, 61, 24, 39, 74, 78, 27, 9, 82, 62, 1, 67, 8, 64, 4, 31, 59, 26, 56, 68, 75, 6, 45, 22, 70, 2, 52, 10, 72, 29, 66, 33, 46, 16, 48, 19, 54, 15, 42, 80, 40, 77, 50, 86, 20, 43, 87, 51, 81, 13, 37, 41, 88, 34]
  //  val lines1c = List("res:    12492   1468.05 6868.317        7318    3663    1421    90      12492   90      RationalQuadratic(alpha=1,_length_scale=1)      100.0   99.838  [(1.0, 1.0), (0.07, 1.0), (1.0, 0.07), (0.64, 1.0), (1.0, 0.64), (1.0, 0.36), (0.36, 1.0), (0.82, 1.0), (1.0, 0.82), (1.0, 0.21), (0.21, 1.0), (1.0, 0.5), (0.5, 1.0), (0.0, 1.0), (1.0, 0.0), (0.93, 0.93), (0.74, 0.95), (0.95, 0.74), (0.07, 0.07), (0.79, 0.07), (0.07, 0.79), (0.21, 0.07), (0.07, 0.64), (0.64, 0.07), (0.07, 0.5), (0.5, 0.07), (0.36, 0.07), (0.07, 0.36), (0.5, 0.79), (0.79, 0.5), (0.79, 0.36), (0.36, 0.79), (0.07, 0.22), (0.5, 0.5), (0.36, 0.5), (0.79, 0.22), (0.64, 0.78), (0.22, 0.79), (1.0, 0.91), (0.79, 0.63), (0.35, 0.36), (0.92, 0.06), (0.06, 0.92), (0.36, 0.22), (0.64, 0.5), (0.36, 0.64), (0.78, 0.78), (0.21, 0.36), (0.29, 0.95), (0.95, 0.29), (0.64, 0.21), (0.91, 1.0), (0.5, 0.21), (0.43, 0.95), (0.95, 0.43), (0.57, 0.95), (0.93, 0.63), (0.21, 0.65), (0.93, 0.18), (0.18, 0.93), (0.64, 0.64), (0.64, 0.36), (0.21, 0.21), (0.82, 0.92), (0.93, 0.52), (0.21, 0.5), (0.5, 0.64), (0.5, 0.36), (1.0, 0.72), (0.65, 0.91), (0.0, 0.07), (0.07, 0.0), (0.36, 0.9), (0.94, 0.0), (0.0, 0.94), (0.73, 1.0), (0.9, 0.36), (0.5, 0.0), (0.0, 0.5), (0.93, 0.83), (0.14, 1.0), (1.0, 0.14), (0.22, 0.0), (0.0, 0.22), (0.78, 0.0), (0.0, 0.78), (0.5, 0.9), (1.0, 0.57), (0.36, 0.0)]  [0, 72, 19, 22, 83, 89, 27, 26, 78, 24, 51, 36, 31, 77, 50, 59, 20, 85, 42, 74, 15, 3, 82, 10, 6, 55, 12, 88, 5, 69, 9, 39, 1, 52, 16, 80, 18, 57, 65, 30, 40, 47, 64, 8, 17, 76, 4, 70, 37, 29, 87, 56, 13, 54, 7, 49, 73, 32, 38, 60, 11, 81, 2, 14, 75, 43, 21, 86, 23, 58, 46, 67, 61, 34, 45, 62, 68, 53, 44, 63, 48, 41, 35, 66, 25, 79, 28, 33, 84, 71]".replace(", ","*").split("[ ]{1,}").mkString("\t").replace("*", ", ")).map { l => l.split('\t').toList.reverse }
  val lines1c = Source.fromFile("../ocean/" + file1c).getLines().toList.tail.filter(!_.startsWith("#")).map { l => l.split('\t').toList.reverse }
  var depot = List(0.0, 0.0)
  val res = lines1c flatMap {
    case (stour: String) :: (spoints: String) :: (tail: List[String]) if allMode || rows.contains(tail.dropRight(1).last) =>
      val tour = stour.tail.dropRight(1).split(", ").toList
      val points = depot :: spoints.drop(2).dropRight(2).split("[)], [(]").toList.map { x => val l = x.split(", ").toList.map(_.toDouble); l }
      val trip = tour.map(i => points(i.toInt))
      println(tail.dropRight(1).last + " " + spoints)
      Some(trip)
    case (stour: String) :: (spoints: String) :: (tail: List[String]) => None
    case x => throw new Error(s"Parsing error! \n$x")
  }
  if (res.isEmpty) throw new Error(s"Timestamps ${rows.mkString(";")} not found!")

  println("tour-after-1-iteration tour-after-2 tour-after-3 ...")
  transpose(res).map(_.flatten.mkString("\t")) foreach println

  def transpose[A](xs: List[List[A]]): List[List[A]] = xs.filter(_.nonEmpty) match {
    case Nil => Nil
    case ys: List[List[A]] => ys.map {
      _.head
    } :: transpose(ys.map {
      _.tail
    })
  }
}

/*
\multirow{2}{*}{1}  & \textbf{$\sigma$} & 7838 & 2097 & 1849 & 1438 &  & 0000 & 0000 & 0000 & 0000 & 0000 & 0000 & 0000 \\
  & \textbf{$\Delta$}  & 0000 & 0000 & 0000 & 0000 & 0000 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
*/
